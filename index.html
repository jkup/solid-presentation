<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>SOLID Object Oriented Design</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/solarized.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>S.O.L.I.D</h1>
					<h3>Object Oriented Design</h3>
					<p>
						<small>Created by <a href="http://www.jonkuperman.com">Jon Kuperman</a> and <a href="http://www.siler.io">Shane Iler</a></small>
					</p>
				</section>

				<section>
					<h2>S.O.L.I.D</h2>
					<p>
						These principles when applied together intend to make it more likely that a programmer will create a system that is easy to maintain and extend over time.
					</p>
					<br />

				</section>

				<section class="principles">
					<h2>The Principles</h2>
					<ol>
					  <li>Single responsibility - <small>A class should only do one thing</small></li>
					  <li>Open-closed - <small>You shouldn't need to change your classes</small></li>
					  <li>Liskov substitution - <small>Child classes should behave like their parents</small></li>
					  <li>Interface segregation - <small>Classes shouldn't know more than they need to</small></li>
					  <li>Dependency inversion - <small>Classes should depend on abstractions, not each other</small></li>
					</ol>
				</section>

				<!-- Example of nested vertical slides -->
				<section>
					<section>
						<h2>Single Responsibility</h2>
						<p>
							A class should have only one reason to change.
						</p>
					</section>
					<section data-background="#F57676">
						<h2>Too Many Responsibilities</h2>
						<pre><code class="php">
class Blog
{
	...

	public function renderPost($id) {
		$post = $this->getPost($id);

		$html = $this->formatPost($post);

		return $html;
	}

	...
}
						</code></pre>
					</section>
					<section>
						<h2>The Problem</h2>
						<p>
						    Classes that do too many things are difficult to extend and are more likely to break when one aspect needs to be changed.
						</p>
					</section>
					<section>
						<h2>Good Example</h2>
						<pre><code class="php">
class Post
{
  public function renderPost(Post $post)
  {
     return View::make('post.display', $post);
  }
}
						</code></pre>
					</section>
				</section>

				<section>
				    <section>
					  <h2>Open-Closed</h2>
					    <p>
						Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.
					    </p>
				    </section>

				    <section data-background="#F57676">
					    <h2>Needs Constant Modification</h2>
					    <pre><code class="php">
    class RenderPost
    {
      public function render(Post $post)
      {
	  if($post->type === 'poll') {
	      return View::make('poll.single', $post);
	  } elseif ($post->type === 'blog') {
	      return View::make('blog.single', $post);
	  } elseif ($post->type === 'video') {
	      return View::make('video.single', $post);
	  }
      }

    }
					    </code></pre>
				    </section>

				    <section>
					<h2>The Problem</h2>
					<p>
					    Classes need to be able to be modified without changing the production source code.
					</p>
				    </section>

				    <section>
					<h2>Good Example</h2>
					<pre><code class="php">
interface Renderable
{
  public function render($post);
}

class Poll extends Post implements Renderable
{
  ...

  public function render($post) {
    return View::make('poll.single', $post);
  }

  ...
}
					</code></pre>
				    </section>
				</section>

				<section>
				    <section>
					<h2>Liskov Substitution Principle</h2>
					<p>
					     If A is a subtype of B, then objects of type B may be replaced with objects of type A.
					</p>
				    </section>

				    <section data-background="#F57676">
					<h2>Different Return Types</h2>
<pre><code class="php">class firstModel implements Model
{
  public function get($id)
  {
    // Returns an object
    return new Post::get($id);
  }
}
class secondModel implements Model
{
  private $results = array();

  public function get($id)
  {
    // Returns an array
    return $results[$id];
  }
}</code></pre>
				    </section>

				    <section>
					<h2>The Problem</h2>
					<p>
					    You find yourself compensating for differences in objects that implement an interface.
					</p>
				    </section>
				    <section>
					<h2>Good Example</h2>
<pre><code class="php">class firstModel implements Model
{
  public function get($id)
  {
    // Returns an object
    return new Post::get($id);
  }
}
class secondModel implements Model
{
  private $results = array();

  public function get($id)
  {
    // Returns an object
    return new Poll::get($id);
  }
}</code></pre>
				  </section>
				</section>

				<section>
				    <section>
					<h2>Interface Segregation</h2>
					<p>
					    A class should not be forced to depend on methods it does not use.
					</p>
				    </section>

				    <section data-background="#F57676">
					<h2>Too Much Information</h2>
					<pre><code class="php">
class Emailer
{
  public function sendEmail(User $user, $message)
  {
    $user->sendEmail($message);
  }
}
					</code></pre>
				    </section>

				    <section>
					<h2>The Problem</h2>
					<p>
					    Using interfaces to further describe the intent of the software is often a good idea.
					</p>
				    </section>

				    <section>
					<h2>Good Example</h2>
					<pre><code class="php">
interface Emailable
{
  public function sendEmail($message);
}

class Emailer
{
  public function sendEmail(Emailable $user, $message)
  {
    $user->sendEmail($message);
  }
}
					</code></pre>
				    </section>
				</section>

				<section>
				    <section>
				      <h2>Dependency Inversion</h2>
				      <p>
					  High-level modules should not depend on low-level modules. Both should depend on abstractions.
				      </p>
				    </section>

				    <section data-background="#F57676">
					<h2>Bad Dependencies</h2>
<pre><code class="php">class MySQLConnection
{
  private hostname;
  private user;
  ...
  public function connect()
  {
    //connect to database
  }
}
class PasswordReminder
{
  public function __construct(MySQLConnect $connection)
  {
    $this->connection = $connection;
  }
}</code></pre>
				    </section>

				    <section>
					<h2>The Problem</h2>
					<p>
					    Classes that instantiate other classes are impossible to test. Furthermore, dependency injection that passes in too much or too specific information breaks the Interface Segregation principle.
					</p>
				    </section>

				    <section>
					<h2>Good Example</h2>
					<pre><code class="php">
interface Connection
{
  public function connect();
}
class MySQLConnection implements Connection
{
  ...
}
class PasswordReminder
{
  public function __construct(Connection $connection)
  {
    ...
  }
}
					</code></pre>
				    </section>
				</section>
				<section>
					<h2>Resources</h2>
					<ul>
					    <li><a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">Princples of OOD</a></li>
					    <li><a href="http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670">Code Complete</a></li>
					    <li><a href="http://c2.com/cgi/wiki?WelcomeVisitors">Portland Patterns Repository</a></li>
					</ul>
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
